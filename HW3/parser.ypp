%{
	extern int yylex();
    extern int yylineno;
	void yyerror(const char*);
	#include "hw3_output.hpp"
	#include "parser.h"
	#include "Table.h"
	SymbolTable* table;
%}

%right ASSIGN;
%left OR;
%left AND;
%left RELOPL;
%nonassoc RELOPN;
%nonassoc RELOP_IN;
%left PLUSMINUS
%left MULDIV;
%left RPAREN;
%left RBRACKET;
%left LBRACKET;
%left LPAREN;

%nonassoc VOID;
%nonassoc INT;
%nonassoc BYTE;
%nonassoc B;
%nonassoc BOOL;
%nonassoc SET;
%nonassoc TRUE;
%nonassoc FALSE;
%nonassoc RETURN;
%nonassoc WHILE;
%nonassoc BREAK;
%nonassoc CONTINUE;
%nonassoc SC;
%nonassoc COMMA;
%nonassoc DOTS;
%nonassoc ID;
%nonassoc NUM;
%nonassoc STRING;
%nonassoc LBRACE;
%nonassoc RBRACE;


%right IF;
%right ELSE;
%right NOT;

%%

Program     :   M Funcs{$$ = $1; table->FinalScopeEnd();}
            ;

M           :   {table = new SymbolTable();}

Funcs       :   {$$ = new Funcs();}   |   FuncDecl Funcs{$$ = new Funcs();}
            ;

FuncDecl    :   RetType ID LPAREN Formals RPAREN {table->addFunction($1, $2, $4);}
                LBRACE Statements RBRACE{table->ScopeEnd();}
            ;

RetType     :   Type{$$ = $1}   |   VOID{$$ = new Type_var("VOID");}
            ;

Formals     :   {$$ = new FormalsList();}   |   FormalsList{$$ = $1;}
            ;

FormalsList :   FormalDecl{$$ = new FormalsList();} |   FormalDecl COMMA FormalsList{$$ = new FormalsList($1, $3);}
            ;

FormalDecl :   Type ID{$$ = new Arguments($1, $2);}
            ;

Statements  :   Statement{$$ = new Statements($1)} |   Statements Statement{$$ = new Statements($2, $1);}
            ;

Statement   :   LBRACE {table->newScope();} Statements RBRACE   {table->ScopeEnd(); $$ = $2;}  |
                Type ID SC                 {table->addVar($1, $2); $$ = new Argument($1, $2);}  |
                Type ID ASSIGN Exp SC      {table->addVar($1, $2); $$ = new Argument($1, $2, $4);}  |
                ID ASSIGN Exp SC           {table->checkValidAssign($1, $3); }  |
                Call SC                    {output::printProductionRule(18);}  |
                RETURN SC                  {output::printProductionRule(19);}  |
                RETURN Exp SC              {output::printProductionRule(20);}  |
                IF LPAREN Exp RPAREN Statement {output::printProductionRule(21);}  |
                IF LPAREN Exp RPAREN Statement ELSE Statement  {output::printProductionRule(22);}  |
                WHILE LPAREN Exp RPAREN Statement  {output::printProductionRule(23);}  |
                BREAK SC                   {output::printProductionRule(24);}  |
                CONTINUE SC                {output::printProductionRule(21);}
            ;

Call        :   ID LPAREN ExpList RPAREN{output::printProductionRule(26);}  |
                ID LPAREN RPAREN        {output::printProductionRule(27);}
            ;

ExpList     :   Exp{output::printProductionRule(28);}   |   Exp COMMA ExpList{output::printProductionRule(29);}
            ;

Type        :   INT{$$ = new Type_var("INT");}   |   BYTE{$$ = new Type_var("BYTE");}  |
                BOOL{$$ = new Type_var("BOOL");}  |
                SET LBRACKET NUM DOTS NUM RBRACKET{$$ = new Type_var("SET", ((Node*)$3)->val, ((Node*)$5)->val);}
            ;

Exp         :   LPAREN Exp RPAREN   {$$ = $2;}   |
                Exp MULDIV Exp      {string type = MulDivType($1->type, $2->type);
                                     $$ = new Expression(); $$->type = type;}   |
                Exp PLUSMINUS Exp   {string type = PlusMinusType($1->type, $2->type);
                                     $$ = new Expression(); $$->type = type;}   |
                ID                  {string type = getVarType($1);
                                     $$ = new Expression(); $$->type = type; $$->name=(((Node*)$1)->val);}   |
                Call                {output::printProductionRule(37);}   |
                NUM                 {$$ = new Expression(); $$->type = "INT"; $$->number = atoi((Node*)$1)->val;}   |
                NUM B               {$$ = new Expression(); $$->type = "BYTE"; $$->number = atoi((Node*)$1)->val;}   |
                STRING              {$$ = new Expression(); $$->type = "STRING"; $$->str = ((Node*)$1)->val;}   |
                TRUE                {$$ = new Expression(); $$->type = "BOOL"; $$->bool_value = true;}   |
                FALSE               {$$ = new Expression(); $$->type = "BOOL"; $$->bool_value = false;}   |
                NOT Exp             {check_valid_bool($2->type); $$ = new Expression(); $$->type = $2->type;}   |
                Exp AND Exp         {check_valid_bool($1->type); check_valid_bool($3->type); $$ = new Expression(); $$->type = "BOOL"}   |
                Exp OR Exp          {check_valid_bool($1->type); check_valid_bool($3->type); $$ = new Expression(); $$->type = "BOOL"}   |
                Exp RELOPL Exp      {check_valid_relop($1->type, $2->type); $$ = new Expression(); $$->type = "BOOL"}   |
                Exp RELOPN Exp      {check_valid_relop($1->type, $2->type); $$ = new Expression(); $$->type = "BOOL"}   |
                Exp RELOP_IN Exp    {check_valid_in($1->type, $2->type); $$ = new Expression(); $$->type = "BOOL"}   |
                LPAREN Type RPAREN Exp  checkValidCast());
                                         $$ = new Expression(); $$->type = type;}
            ;

%%

int main()
{
	return yyparse();
}

void yyerror(const char * message)
{
	output::errorSyn(yylineno);
	exit(0);
}

void checkValidCast(string type, string exp_type){
    if(exp_type != "SET" || type != "INT"){
        output::errorMismatch(yylineno);
        exit(0);
    }
}

string PlusMinusType(string a, string b){
   if(a == b){
        //both have same type
        return a;
   }
   if(a == "INT" && b == "BYTE"){
        return "INT";
   }
   if(a == "SET"){
	    if(b == "BYTE" || b == "INT"){
	        return "SET";
	    }
   }
   else if (b == "SET"){
       if(a == "BYTE" || a == "INT"){
       	        return "SET";
       	    }
   }
   output::errorMismatch(yylineno);
   exit(0);
}

string MulDivType(string a, string b){
   if(a == b){
        //both have same type
        return a;
   }
   if(a == "INT" && b == "BYTE"){
        return "INT";
   }
   output::errorMismatch(yylineno);
   exit(0);
}

void check_valid_bool(string exp){
    if(exp != "BOOL")){
      output::errorMismatch(yylineno);
      exit(0);
   }
}

void check_valid_in(string type1, string type2){
    if((type1 == "INT" || type1 == "BYTE") && type2 == "SET"){
        return;
    }
    output::errorMismatch(yylineno);
    exit(0);
}

void check_valid_relop(string type1, string type2){
    if((type1 == "INT" || type1 == "BYTE") && (type2 == "INT" || type2 == "BYTE")){
        return;
    }
    output::errorMismatch(yylineno);
    exit(0);
}