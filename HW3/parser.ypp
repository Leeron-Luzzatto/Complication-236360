%{
	extern int yylex();
    extern int yylineno;
	void yyerror(const char*);
	#include "hw3_output.hpp"
	#include "parser.h"
	#include "Table.h"
	SymbolTable* table;
%}

%right ASSIGN;
%left OR;
%left AND;
%left RELOPL;
%nonassoc RELOPN;
%left PLUSMINUS
%left MULDIV;
%left RPAREN;
%left RBRACKET;
%left LBRACKET;
%left LPAREN;

%nonassoc VOID;
%nonassoc INT;
%nonassoc BYTE;
%nonassoc B;
%nonassoc BOOL;
%nonassoc SET;
%nonassoc TRUE;
%nonassoc FALSE;
%nonassoc RETURN;
%nonassoc WHILE;
%nonassoc BREAK;
%nonassoc CONTINUE;
%nonassoc SC;
%nonassoc COMMA;
%nonassoc DOTS;
%nonassoc ID;
%nonassoc NUM;
%nonassoc STRING;
%nonassoc LBRACE;
%nonassoc RBRACE;


%right IF;
%right ELSE;
%right NOT;

%%

Program     :   M Funcs{$$ = $1; table->ScopeEnd();}
            ;

M           :   {table = new SymbolTable();}

Funcs       :   {$$ = new Funcs();}   |   FuncDecl Funcs{$$ = new Funcs();}
            ;

FuncDecl    :   RetType ID LPAREN Formals RPAREN {table->addFunction($1, $2, $4);}
                LBRACE Statements RBRACE{table->ScopeEnd();}
            ;

RetType     :   Type{$$ = $1}   |   VOID{$$ = $1}
            ;

Formals     :   {$$ = new FormalsList();}   |   FormalsList{$$ = $1;}
            ;

FormalsList :   FormalDecl{$$ = new FormalsList();} |   FormalDecl COMMA FormalsList{$$ = new FormalsList($1, $3);}
            ;

FormalDecl :   Type ID{$$ = new Arguments($1, $2);}
            ;

Statements  :   Statement{$$ = new Statements($1)} |   Statements Statement{$$ = new Statements($2, $1);}
            ;

Statement   :   LBRACE {table->newScope();} Statements RBRACE   {table->ScopeEnd(); $$ = $2;}  |
                Type ID SC                 {table->addVar($1, $2); $$ = new Argument($1, $2);}  |
                Type ID ASSIGN Exp SC      {table->addVar($1, $2); $$ = new Argument($1, $2, $4);}  |
                ID ASSIGN Exp SC           {output::printProductionRule(17);}  |
                Call SC                    {output::printProductionRule(18);}  |
                RETURN SC                  {output::printProductionRule(19);}  |
                RETURN Exp SC              {output::printProductionRule(20);}  |
                IF LPAREN Exp RPAREN Statement {output::printProductionRule(21);}  |
                IF LPAREN Exp RPAREN Statement ELSE Statement  {output::printProductionRule(22);}  |
                WHILE LPAREN Exp RPAREN Statement  {output::printProductionRule(23);}  |
                BREAK SC                   {output::printProductionRule(24);}  |
                CONTINUE SC                {output::printProductionRule(21);}
            ;

Call        :   ID LPAREN ExpList RPAREN{output::printProductionRule(26);}  |
                ID LPAREN RPAREN        {output::printProductionRule(27);}
            ;

ExpList     :   Exp{output::printProductionRule(28);}   |   Exp COMMA ExpList{output::printProductionRule(29);}
            ;

Type        :   INT{output::printProductionRule(30);}   |   BYTE{output::printProductionRule(31);}  |
                BOOL{output::printProductionRule(32);}  |
                SET LBRACKET NUM DOTS NUM RBRACKET{output::printProductionRule(33);}
            ;

Exp         :   LPAREN Exp RPAREN   {output::printProductionRule(34);}   |
                Exp MULDIV Exp      {output::printProductionRule(35);}   |
                Exp PLUSMINUS Exp   {output::printProductionRule(35);}   |
                ID                  {output::printProductionRule(36);}   |
                Call                {output::printProductionRule(37);}   |
                NUM                 {output::printProductionRule(38);}   |
                NUM B               {output::printProductionRule(39);}   |
                STRING              {output::printProductionRule(40);}   |
                TRUE                {output::printProductionRule(41);}   |
                FALSE               {output::printProductionRule(42);}   |
                NOT Exp             {output::printProductionRule(43);}   |
                Exp AND Exp         {output::printProductionRule(44);}   |
                Exp OR Exp          {output::printProductionRule(45);}   |
                Exp RELOPL Exp      {output::printProductionRule(46);}   |
                Exp RELOPN Exp      {output::printProductionRule(46);}   |
                LPAREN Type RPAREN Exp  {output::printProductionRule(47);}
            ;

%%

int main()
{
	return yyparse();
}

void yyerror(const char * message)
{
	output::errorSyn(yylineno);
	exit(0);
}